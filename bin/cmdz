#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=C0116,C0413,W0212,C0301,W0613


"shell"


## imports


import atexit
import importlib
import importlib.util
import os
import readline
import rlcompleter
import sys
import time
import termios


sys.path.insert(0, os.getcwd())


from cmdz.message import Event
from cmdz.handler import Command, Handler
from cmdz.objects import Wd, printable
from cmdz.running import Cfg, boot, command, scandir, scanner
from cmdz.threads import launch


## defines


Cfg.name = "cmdzsh"


## classes


Cfg.name = "cmdz"
Wd.workdir = os.path.expanduser("~/.cmdz")


class CLI(Handler):

    @staticmethod
    def announce(txt):
        pass

    @staticmethod
    def raw(txt):
        print(txt)
        sys.stdout.flush()



class Console(Handler):

    @staticmethod
    def announce(txt):
        pass

    @staticmethod
    def handle(event):
        Command.handle(event)
        event.wait()

    def poll(self):
        event = Event()
        event.txt = input("> ")
        event.orig = repr(self)
        return event

    @staticmethod
    def raw(txt):
        print(txt)
        sys.stdout.flush()


class Completer(rlcompleter.Completer):

    def __init__(self, options):
        rlcompleter.Completer.__init__(self)
        self.matches = []
        self.options = options

    def complete(self, text, state):
        if state == 0:
            if text:
                self.matches = [
                                s for s in self.options
                                if s and s.startswith(text)
                               ]
            else:
                self.matches = self.options[:]
        try:
            return self.matches[state]
        except IndexError:
            return None


## utiltiy


def daemon():
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    os.umask(0)
    sis = open("/dev/null", 'r')
    os.dup2(sis.fileno(), sys.stdin.fileno())
    if not Cfg.verbose:
        sos = open("/dev/null", 'a+')
        ses = open("/dev/null", 'a+')
        os.dup2(sos.fileno(), sys.stdout.fileno())
        os.dup2(ses.fileno(), sys.stderr.fileno())


def importer(mname, path):
    spec = importlib.util.find_spec(mname)
    if spec:
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        if "init" in dir(mod):
            launch(mod.init)
        return mod
    return None


def print_exc(ex):
    traceback.print_exception(type(ex), ex, ex.__traceback__)


def setcompleter(optionlist):
    completer = Completer(optionlist)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))


def setcompleter(optionlist):
    completer = Completer(optionlist)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))


def wrap(func):
    fds = sys.stdin.fileno()
    gotterm = True
    try:
        old = termios.tcgetattr(fds)
    except termios.error:
        gotterm = False
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        if gotterm:
            termios.tcsetattr(fds, termios.TCSADRAIN, old)
        for evt in Command.errors:
            print_exc(evt.__exc__)


## commands


def disable(event):
    if not event.args:
        event.reply("disable <modname>")
        return
    name = event.args[0]
    if name == "disable":
        event.reply("i won't disable myself")
        return
    path = os.path.join(Wd.moddir(), name + ".py")
    splitted = path.split()
    splitted[-2] = "disable"
    newpath = os.sep.join(splitted)
    shutil.move(path, newpath)
    event.ok(newpath)


def enable(event):
    if not event.args:
        event.reply("enable <modname>")
        return
    name = event.args[0]
    if name == "enable":
        event.reply("i won't enable myself")
        return
    path = os.path.join(Wd.disable(), name + ".py")
    splitted[-2] = "modz"
    newpath = os.sep.join(splitted)
    shutil.move(path, newpath)
    event.ok(newpath)


## runtime


def main():
    boot()
    Command.add(disable)
    Command.add(enable)
    scandir(Wd.moddir(), importer, "modz")
    setcompleter(Command.cmd)
    if Cfg.prs.txt:
        cli = CLI()
        return command(cli, Cfg.prs.otxt)
    if Cfg.console:
        date = time.ctime(time.time()).replace("  ", " ")
        print("%s started at %s %s" % (Cfg.name.upper(), date, printable(Cfg, plain=True)))
        cli = Console()
        cli.start()
     

wrap(main)
